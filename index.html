<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>HSK Word Tower Defense</title>
<style>
:root {
  --bg: #0a0f1f;
  --panel: #111633;
  --panel-2: #0f1430;
  --accent: #66f7c2;
  --accent2: #8bb6ff;
  --danger: #ff6b6b;
  --warn: #ffbb55;
  --text: #e9ecff;
  --muted: #9aa3c7;
  --good: #35e39a;
  --bad: #ff6b6b;
  --lane: #1a214d;
}
* { box-sizing: border-box; }
body {
  margin: 0; background: radial-gradient(1200px 600px at 50% -10%, #0d1542 0%, #090d1f 60%, #070a17 100%);
  color: var(--text);
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
  display: flex; flex-direction: column; min-height: 100vh;
}
header {
  padding: 10px 14px; background: linear-gradient(180deg, var(--panel), #0c1130);
  display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: space-between;
  position: sticky; top: 0; z-index: 3; border-bottom: 1px solid #20265c;
}
header .left, header .right { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
.badge { padding: 6px 10px; background: #1a2053; border: 1px solid #2a3280; border-radius: 10px; font-weight: 600; }
.badge.strong { background: #1a2c57; border-color: #3656b3; }
.heart { color: var(--danger); }
.combo { color: var(--accent); font-weight: 800; }
.progress-wrap { width: 180px; height: 10px; background: #141a45; border: 1px solid #2a3280; border-radius: 999px; overflow: hidden; }
.progress { height: 100%; width: 0%; background: linear-gradient(90deg, #46d8ff, #66f7c2); transition: width .25s ease; }

.btn {
  background: #22264a; color: var(--text); border: 1px solid #31386b; border-radius: 10px;
  padding: 8px 12px; font-weight: 700;
}
.btn:active { transform: translateY(1px); }
.btn.primary { background: linear-gradient(135deg, #2e335f, #3540a3); border-color: #4b56c0; }
.btn.good { background: #123a2a; border-color: #1f6b53; color: #b1ffe2; }
.btn.warn { background: #3a2a12; border-color: #6b511f; color: #ffe7b1; }
.btn.danger { background: #3a1a1a; border-color: #7d2c2c; color: #ffc7c7; }
.toggle {
  display: inline-flex; border: 1px solid #31386b; border-radius: 999px; overflow: hidden;
}
.toggle button {
  background: transparent; color: var(--muted); border: 0; padding: 8px 12px; font-weight: 700;
}
.toggle button.active { background: #2b3269; color: white; }

main { flex: 1; display: flex; flex-direction: column; }
#game {
  position: relative; flex: 1; display: flex; align-items: center; justify-content: center; padding: 8px;
}
canvas { width: 100%; max-width: 700px; height: 60vh; background: #0a0d1b; border: 1px solid #1f2450; border-radius: 14px; }

.footer-ui {
  background: var(--panel-2); border-top: 1px solid #20265c;
  display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; padding: 12px;
  position: sticky; bottom: 0; z-index: 2;
}
.choice {
  background: #12183f; border: 1px solid #2a3167; padding: 12px; border-radius: 12px; text-align: center;
  font-size: 16px; font-weight: 800; color: #eaf0ff;
}
.choice.correct { outline: 2px solid #4be6a5; background: #123a2a; }
.choice.wrong { outline: 2px solid #ff6b6b; background: #3a1a1a; }
.choice.locked { opacity: 0.7; pointer-events: none; }

.powerups {
  display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 8px 12px 0 12px;
}
.pill {
  display: inline-flex; align-items: center; gap: 8px;
  background: #12183f; border: 1px solid #2a3167; color: #bcd1ff;
  padding: 8px 10px; border-radius: 999px; font-weight: 700; justify-content: center;
}
.pill .count { background: #1a214d; padding: 2px 8px; border-radius: 999px; border: 1px solid #2a3167; min-width: 24px; text-align: center; }

.overlay {
  position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
  background: rgba(10,12,24,0.78); z-index: 4; padding: 16px;
}
.card {
  width: 100%; max-width: 520px; background: #121533; border: 1px solid #2c3473; border-radius: 16px;
  padding: 16px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}
.card h1 { margin: 0 0 6px; font-size: 22px; }
.card p { margin: 6px 0 12px; color: var(--muted); }
.row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px; }
select, .btn, .choice { touch-action: manipulation; }

.hint {
  color: #bcd1ff; font-size: 13px; opacity: .9; padding: 6px 0;
}
.example {
  color: #a3ffd8; font-size: 13px; margin-top: 6px;
}

.toast {
  position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
  background: rgba(18, 21, 51, .9); border: 1px solid #2a3167; padding: 6px 10px; border-radius: 999px;
  font-weight: 800; color: #bcd1ff; z-index: 5; pointer-events: none;
}

.sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0; }
</style>
</head>
<body>
<header>
  <div class="left">
    <span class="badge strong">Score: <span id="score">0</span></span>
    <span class="badge">Wave: <span id="wave">1</span></span>
    <span class="badge">Lives: <span id="lives">3</span> <span class="heart" aria-hidden="true">❤</span></span>
    <span class="badge">Combo: <span id="combo" class="combo">x1</span></span>
    <span class="badge" title="High score">🏆 <span id="highScore">0</span></span>
    <div class="progress-wrap" aria-label="Wave progress">
      <div id="waveProgress" class="progress"></div>
    </div>
  </div>
  <div class="right">
    <div class="toggle" role="tablist" aria-label="Answer mode">
      <button id="modePinyin" class="active" aria-selected="true">Pinyin</button>
      <button id="modeEnglish" aria-selected="false">English</button>
    </div>
    <div class="toggle" role="tablist" aria-label="Learning mode">
      <button id="modePractice" class="active" aria-selected="true" title="Hints on, slower">Learning</button>
      <button id="modeArcade" aria-selected="false" title="Hints off, faster">Arcade</button>
    </div>
    <select id="levelSelect" aria-label="HSK level">
      <option value="1" selected>HSK 1</option>
      <option value="2">HSK 2</option>
      <option value="3">HSK 3</option>
    </select>
    <button id="pauseBtn" class="btn" aria-pressed="false" aria-label="Pause">Pause</button>
  </div>
</header>

<main>
  <div id="game" role="application" aria-label="HSK Word Tower Defense">
    <canvas id="canvas" width="700" height="420" aria-hidden="true"></canvas>

    <div id="startOverlay" class="overlay" aria-modal="true" role="dialog">
      <div class="card">
        <h1>HSK Word Tower Defense</h1>
        <p>Stop the characters before they reach your base. Tap the correct answer fast.</p>
        <div class="row">
          <div class="toggle" role="tablist" aria-label="Answer mode (start)">
            <button id="startModePinyin" class="active" aria-selected="true">Pinyin</button>
            <button id="startModeEnglish" aria-selected="false">English</button>
          </div>
          <select id="startLevel" aria-label="Start level">
            <option value="1" selected>HSK 1</option>
            <option value="2">HSK 2</option>
            <option value="3">HSK 3</option>
          </select>
        </div>
        <div class="row">
          <button id="startBtn" class="btn primary">Start</button>
        </div>
        <p class="hint">Tip: Toggle Pinyin/English anytime. Each success speeds up the wave.</p>
      </div>
    </div>

    <div id="bonusOverlay" class="overlay" style="display:none;" aria-modal="true" role="dialog">
      <div class="card">
        <h1>Bonus Round</h1>
        <p>15 seconds of double points. Enemies spawn faster. Ready?</p>
        <div class="row">
          <button id="bonusStartBtn" class="btn primary">Go!</button>
        </div>
      </div>
    </div>

    <div id="gameOverOverlay" class="overlay" style="display:none;" aria-modal="true" role="dialog">
      <div class="card">
        <h1>Game Over</h1>
        <p>Final score: <strong id="finalScore">0</strong></p>
        <p>High score: <strong id="finalHighScore">0</strong></p>
        <div class="row">
          <button id="restartBtn" class="btn primary">Play again</button>
        </div>
      </div>
    </div>

    <div id="toast" class="toast" style="display:none;" aria-live="polite"></div>
    <div id="srLive" class="sr-only" aria-live="assertive"></div>
  </div>

  <div class="powerups" aria-label="Power-ups">
    <button id="puFreeze" class="pill" title="Freeze enemies for 4s">
      ❄ Freeze <span class="count" id="countFreeze">1</span>
    </button>
    <button id="puBomb" class="pill" title="Defeat front enemy instantly">
      💣 Bomb <span class="count" id="countBomb">1</span>
    </button>
    <button id="puDouble" class="pill" title="Double points for 10s">
      ✨ x2 <span class="count" id="countDouble">1</span>
    </button>
  </div>

  <div class="footer-ui" id="choices" aria-label="Answer choices"></div>
</main>

<script>
// -------------------------- Word banks with example sentences --------------------------
const WORDS = {
  1: [
    { hanzi: "你", pinyin: "nǐ", english: "you", sentence: "你好吗？" },
    { hanzi: "好", pinyin: "hǎo", english: "good", sentence: "今天天气很好。" },
    { hanzi: "吗", pinyin: "ma", english: "(question particle)", sentence: "你是学生吗？" },
    { hanzi: "我", pinyin: "wǒ", english: "I; me", sentence: "我是中国人。" },
    { hanzi: "爱", pinyin: "ài", english: "love", sentence: "我爱中文。" },
    { hanzi: "学", pinyin: "xué", english: "study; learn", sentence: "我学汉语。" },
    { hanzi: "中", pinyin: "zhōng", english: "middle; China", sentence: "中文很有意思。" },
    { hanzi: "国", pinyin: "guó", english: "country", sentence: "中国很大。" },
    { hanzi: "人", pinyin: "rén", english: "person", sentence: "他是好人。" },
    { hanzi: "吃", pinyin: "chī", english: "eat", sentence: "我爱吃饺子。" },
  ],
  2: [
    { hanzi: "帮助", pinyin: "bāngzhù", english: "help", sentence: "谢谢你的帮助。" },
    { hanzi: "因为", pinyin: "yīnwèi", english: "because", sentence: "因为下雨，所以不去。" },
    { hanzi: "所以", pinyin: "suǒyǐ", english: "therefore", sentence: "太晚了，所以回家。" },
    { hanzi: "意思", pinyin: "yìsi", english: "meaning", sentence: "这个词什么意思？" },
    { hanzi: "问题", pinyin: "wèntí", english: "question; problem", sentence: "我有一个问题。" },
    { hanzi: "告诉", pinyin: "gàosu", english: "tell", sentence: "请告诉我时间。" },
  ],
  3: [
    { hanzi: "地图", pinyin: "dìtú", english: "map", sentence: "请看这张地图。" },
    { hanzi: "热情", pinyin: "rèqíng", english: "enthusiastic", sentence: "他很热情。" },
    { hanzi: "环境", pinyin: "huánjìng", english: "environment", sentence: "这里环境很安静。" },
    { hanzi: "提高", pinyin: "tígāo", english: "improve", sentence: "我想提高口语。" },
    { hanzi: "重要", pinyin: "zhòngyào", english: "important", sentence: "健康很重要。" },
    { hanzi: "练习", pinyin: "liànxí", english: "practice", sentence: "多练习会更好。" },
  ],
};

// -------------------------- Game state --------------------------
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const scoreEl = document.getElementById("score");
const highScoreEl = document.getElementById("highScore");
const finalHighScoreEl = document.getElementById("finalHighScore");
const waveEl = document.getElementById("wave");
const livesEl = document.getElementById("lives");
const comboEl = document.getElementById("combo");
const waveProgressEl = document.getElementById("waveProgress");
const startOverlay = document.getElementById("startOverlay");
const bonusOverlay = document.getElementById("bonusOverlay");
const gameOverOverlay = document.getElementById("gameOverOverlay");
const finalScoreEl = document.getElementById("finalScore");
const choicesEl = document.getElementById("choices");
const pauseBtn = document.getElementById("pauseBtn");
const levelSelect = document.getElementById("levelSelect");
const modePinyinBtn = document.getElementById("modePinyin");
const modeEnglishBtn = document.getElementById("modeEnglish");
const modePracticeBtn = document.getElementById("modePractice");
const modeArcadeBtn = document.getElementById("modeArcade");
const startModePinyin = document.getElementById("startModePinyin");
const startModeEnglish = document.getElementById("startModeEnglish");
const startLevel = document.getElementById("startLevel");
const startBtn = document.getElementById("startBtn");
const bonusStartBtn = document.getElementById("bonusStartBtn");
const restartBtn = document.getElementById("restartBtn");
const toast = document.getElementById("toast");
const srLive = document.getElementById("srLive");

const puFreezeBtn = document.getElementById("puFreeze");
const puBombBtn = document.getElementById("puBomb");
const puDoubleBtn = document.getElementById("puDouble");
const countFreeze = document.getElementById("countFreeze");
const countBomb = document.getElementById("countBomb");
const countDouble = document.getElementById("countDouble");

let running = false;
let paused = false;
let mode = "pinyin";   // "pinyin" | "english"
let learnMode = true;  // Learning vs Arcade
let level = 1;

let score = 0;
let lives = 3;
let wave = 1;
let enemies = [];
let particles = [];
let lastSpawn = 0;
let spawnInterval = 1400; // ms
let baseSpeed = 45; // px/s
let laneY;
let lanes = []; // y coordinates
let waveGoal = 10; // enemies to defeat to advance wave
let waveKills = 0;
let currentTargetWord = null;
let choicesLocked = false;

let combo = 0;
let multiplier = 1;
let multiplierTimer = 0;

let powerups = { freeze: 1, bomb: 1, double: 1 };
let freezeTimer = 0;
let doubleTimer = 0;

let inBonus = false;
let bonusTimer = 0;

let lastTime = 0;

// Progress tracking per word (accuracy)
let stats = loadStats();
let highScore = Number(localStorage.getItem("hsk_td_highscore") || 0);
highScoreEl.textContent = highScore;

// -------------------------- Utilities --------------------------
function randChoice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

function announce(msg) {
  srLive.textContent = "";
  setTimeout(() => srLive.textContent = msg, 10);
}

function showToast(msg, ms = 1000) {
  toast.textContent = msg;
  toast.style.display = "block";
  setTimeout(() => { toast.style.display = "none"; }, ms);
}

function speak(text, lang = "zh-CN") {
  try {
    const u = new SpeechSynthesisUtterance(text);
    u.lang = lang;
    u.rate = 0.95;
    speechSynthesis.speak(u);
  } catch(e) {}
}

// -------------------------- Enemy types --------------------------
// Types: normal, fast, tank, sneaky
function createEnemy(word) {
  const typeRoll = Math.random();
  let type = "normal";
  if (typeRoll > 0.85) type = "tank";
  else if (typeRoll > 0.65) type = "fast";
  else if (typeRoll > 0.45) type = "sneaky";

  const lane = randChoice(lanes);
  const baseW = 56, baseH = 56;
  const e = {
    x: canvas.width + 20,
    y: lane,
    w: baseW, h: baseH,
    baseColor: "#1b245a",
    stroke: "#2e3b86",
    speed: baseSpeed,
    hp: 1,
    maxHp: 1,
    word, type,
    bobT: Math.random() * Math.PI * 2,
    alpha: 1,
    hitFlash: 0,
  };

  switch(type) {
    case "fast":
      e.speed *= 1.45;
      e.baseColor = "#163a59";
      e.stroke = "#2a6a9a";
      break;
    case "tank":
      e.hp = e.maxHp = 2 + Math.floor(wave / 3);
      e.w = 68; e.h = 68;
      e.baseColor = "#2b2b44";
      e.stroke = "#5858a8";
      break;
    case "sneaky":
      e.baseColor = "#121a3f";
      e.stroke = "#3d3d7a";
      e.alpha = 0.6;
      break;
  }
  return e;
}

function spawnEnemy() {
  const word = randChoice(WORDS[level]);
  const e = createEnemy(word);
  enemies.push(e);
  // Lock-choices: only build choices if we don't have a current target
  if (!currentTargetWord) {
    currentTargetWord = e.word;
    buildChoices(currentTargetWord);
  }
}

function hitEffect(x, y, good = true) {
  const count = 16;
  for (let i = 0; i < count; i++) {
    const ang = Math.random() * Math.PI * 2;
    const sp = (good ? 80 : 60) + Math.random() * (good ? 90 : 70);
    particles.push({
      x, y, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp,
      life: 0.5 + Math.random() * 0.4,
      age: 0,
      color: good ? "#66f7c2" : "#ff6b6b",
      size: good ? 3 : 2,
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.age += dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 120 * dt;
    if (p.age >= p.life) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    const t = 1 - p.age / p.life;
    ctx.globalAlpha = t;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * (0.7 + 0.6 * t), 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// -------------------------- Choices & Answering --------------------------
function buildChoices(targetWord) {
  const bank = WORDS[level];
  const opts = new Set([targetWord]);
  while (opts.size < 4) opts.add(randChoice(bank));
  const shuffled = shuffle([...opts]);
  choicesEl.innerHTML = "";
  shuffled.forEach(opt => {
    const btn = document.createElement("button");
    btn.className = "choice";
    btn.setAttribute("aria-label", `Answer ${mode === "pinyin" ? opt.pinyin : opt.english}`);
    btn.textContent = mode === "pinyin" ? opt.pinyin : opt.english;

    if (learnMode && mode === "english" && opt === targetWord) {
      btn.title = targetWord.pinyin; // subtle hint
    }

    btn.onclick = () => {
      if (choicesLocked) return;
      const isCorrect = opt === targetWord;
      if (isCorrect) {
        onCorrect(targetWord);
        btn.classList.add("correct");
        setTimeout(() => btn.classList.remove("correct"), 200);
      } else {
        onWrong();
        btn.classList.add("wrong");
        setTimeout(() => btn.classList.remove("wrong"), 250);
      }
    };
    choicesEl.appendChild(btn);
  });

  if (learnMode) {
    const ex = document.createElement("div");
    ex.className = "example";
    ex.textContent = `例句: ${targetWord.sentence}`;
    choicesEl.appendChild(ex);
  }
}

function killFrontMatching(targetWord) {
  let idx = -1;
  let minX = Infinity;
  for (let i = 0; i < enemies.length; i++) {
    const e = enemies[i];
    if (e.word === targetWord && e.x < minX) {
      minX = e.x; idx = i;
    }
  }
  if (idx !== -1) {
    const e = enemies[idx];
    hitEffect(e.x, e.y, true);
    enemies.splice(idx, 1);
    return { x: e.x, y: e.y };
  }
  return null;
}

function onCorrect(targetWord) {
  // Audio pronunciation
  speak(targetWord.hanzi, "zh-CN");

  choicesLocked = true;
  stats[targetWord.hanzi] = stats[targetWord.hanzi] || { seen: 0, correct: 0 };
  stats[targetWord.hanzi].seen++;
  stats[targetWord.hanzi].correct++;
  saveStats();

  // Combo mechanics
  combo += 1;
  multiplier = 1 + Math.floor(combo / 5);
  multiplier = clamp(multiplier, 1, 5);
  comboEl.textContent = `x${multiplier}`;
  multiplierTimer = 3; // seconds to maintain multiplier

  const pos = killFrontMatching(targetWord);
  const basePoints = 10;
  const points = basePoints * multiplier * (doubleTimer > 0 || inBonus ? 2 : 1);
  score += points;
  scoreEl.textContent = score;

  waveKills++;
  updateWaveProgress();

  // Difficulty ramp
  if (waveKills >= waveGoal && !inBonus) {
    wave++;
    waveEl.textContent = wave;
    waveKills = 0;
    waveGoal = Math.min(20, waveGoal + 2);
    baseSpeed += 6;
    spawnInterval = Math.max(600, spawnInterval - 80);
    showToast(`Wave ${wave}!`);
    // Bonus round every 3 waves
    if (wave % 3 === 0) {
      pauseForBonus();
      return;
    }
  }

  // Particles already triggered in killFrontMatching
  if (pos) {
    // small enemy hit flash handled elsewhere
  }

  // Power-up drops (rare)
  maybeDropPowerup();

  // Next target
  setTimeout(() => {
    choicesLocked = false;
    currentTargetWord = null;
    if (enemies.length > 0) {
      let frontmost = enemies.reduce((p, c) => (p.x < c.x ? p : c));
      currentTargetWord = frontmost.word;
      buildChoices(currentTargetWord);
    } else {
      choicesEl.innerHTML = "";
    }
  }, 120);
}

function onWrong() {
  // Shake, particles
  screenShake();
  hitEffect(canvas.width * 0.12, canvas.height * 0.5, false);

  // Reset combo
  combo = 0;
  multiplier = 1;
  comboEl.textContent = `x${multiplier}`;

  // Learning mode hint: 50/50 after a wrong
  if (learnMode) {
    revealHint();
  }

  // Lose life
  lives -= 1;
  livesEl.textContent = lives;
  if (lives <= 0) {
    gameOver();
  }
}

// -------------------------- Hints --------------------------
function revealHint() {
  const buttons = [...choicesEl.querySelectorAll(".choice")];
  if (buttons.length < 4) return;
  // Keep correct, disable 2 wrong
  const correctText = mode === "pinyin" ? currentTargetWord.pinyin : currentTargetWord.english;
  const wrongs = buttons.filter(b => b.textContent !== correctText);
  shuffle(wrongs).slice(0, 2).forEach(b => {
    b.classList.add("locked");
    b.disabled = true;
    b.setAttribute("aria-disabled", "true");
  });
}

// -------------------------- Power-ups --------------------------
function updatePowerupUI() {
  countFreeze.textContent = powerups.freeze;
  countBomb.textContent = powerups.bomb;
  countDouble.textContent = powerups.double;
}
function useFreeze() {
  if (powerups.freeze <= 0) return;
  powerups.freeze--;
  freezeTimer = 4; // seconds
  showToast("Freeze!");
  updatePowerupUI();
}
function useBomb() {
  if (powerups.bomb <= 0) return;
  powerups.bomb--;
  // Kill front-most enemy
  if (enemies.length) {
    let frontmost = enemies.reduce((p, c) => (p.x < c.x ? p : c));
    hitEffect(frontmost.x, frontmost.y, true);
    enemies.splice(enemies.indexOf(frontmost), 1);
  }
  showToast("Boom!");
  updatePowerupUI();
}
function useDouble() {
  if (powerups.double <= 0) return;
  powerups.double--;
  doubleTimer = 10;
  showToast("Double Points!");
  updatePowerupUI();
}
function maybeDropPowerup() {
  const r = Math.random();
  if (r > 0.95) { powerups.freeze++; showToast("Got ❄ Freeze"); }
  else if (r > 0.90) { powerups.bomb++; showToast("Got 💣 Bomb"); }
  else if (r > 0.86) { powerups.double++; showToast("Got ✨ x2"); }
  updatePowerupUI();
}

// -------------------------- Bonus round --------------------------
function pauseForBonus() {
  inBonus = true;
  paused = true;
  bonusOverlay.style.display = "flex";
}
function startBonus() {
  bonusOverlay.style.display = "none";
  paused = false;
  bonusTimer = 15; // seconds
  showToast("Bonus Round!");
  // Turbo spawns during bonus
  spawnInterval = Math.max(350, spawnInterval - 250);
}

// -------------------------- Drawing --------------------------
function drawBackground() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Lanes
  ctx.strokeStyle = "#1a214d";
  ctx.lineWidth = 1;
  for (const y of lanes) {
    ctx.globalAlpha = 0.35;
    ctx.beginPath();
    ctx.moveTo(0, y + 30);
    ctx.lineTo(canvas.width, y + 30);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // Base zone
  ctx.fillStyle = "rgba(255,107,107,0.08)";
  ctx.fillRect(0, lanes[1] - 10, 70, 50);
  ctx.strokeStyle = "#ff6b6b";
  ctx.strokeRect(4, lanes[1] - 8, 64, 46);

  // Faint grid
  ctx.strokeStyle = "rgba(100,120,200,0.06)";
  for (let x = 0; x < canvas.width; x += 30) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
  }
}

function roundRect(ctx, x, y, w, h, r) {
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

function drawEnemy(e, dt) {
  // Bobbing
  e.bobT += dt * 2;
  const bob = Math.sin(e.bobT) * 2;

  ctx.save();
  ctx.globalAlpha = e.alpha;
  // Shadow
  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.beginPath();
  ctx.ellipse(e.x, e.y + e.h/2 + 8, e.w/2.5, 6, 0, 0, Math.PI * 2);
  ctx.fill();

  // Body
  const bodyX = e.x - e.w/2;
  const bodyY = e.y - e.h/2 + bob;
  ctx.fillStyle = e.hitFlash > 0 ? "#ffef88" : e.baseColor;
  ctx.strokeStyle = e.stroke;
  ctx.lineWidth = 2;
  roundRect(ctx, bodyX, bodyY, e.w, e.h, 18);
  ctx.fill();
  ctx.stroke();

  // Hanzi
  ctx.fillStyle = "#e9ecff";
  ctx.font = `bold ${Math.floor(e.h * 0.6)}px system-ui, sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(e.word.hanzi, e.x, e.y + bob);

  // HP bar for tanks
  if (e.maxHp > 1) {
    const barW = e.w, barH = 6;
    const pct = e.hp / e.maxHp;
    ctx.fillStyle = "#2a2f62";
    ctx.fillRect(e.x - barW/2, bodyY - 10, barW, barH);
    ctx.fillStyle = "#66f7c2";
    ctx.fillRect(e.x - barW/2, bodyY - 10, barW * pct, barH);
    ctx.strokeStyle = "#1e2455";
    ctx.strokeRect(e.x - barW/2, bodyY - 10, barW, barH);
  }

  ctx.restore();

  if (e.hitFlash > 0) e.hitFlash -= dt;
}

function screenShake() {
  const start = performance.now();
  const dur = 200;
  const originalStyle = canvas.style.transform;
  function s(t) {
    const p = (t - start) / dur;
    if (p >= 1) { canvas.style.transform = originalStyle; return; }
    const dx = (Math.random() - 0.5) * 10;
    const dy = (Math.random() - 0.5) * 6;
    canvas.style.transform = `translate(${dx}px, ${dy}px)`;
    requestAnimationFrame(s);
  }
  requestAnimationFrame(s);
}

// -------------------------- Loop --------------------------
function loop(ts) {
  if (!running || paused) return;

  const dt = lastTime ? (ts - lastTime) / 1000 : 0;
  lastTime = ts;

  // Timers
  if (freezeTimer > 0) freezeTimer -= dt;
  if (doubleTimer > 0) doubleTimer -= dt;
  if (multiplierTimer > 0) {
    multiplierTimer -= dt;
    if (multiplierTimer <= 0) {
      combo = 0; multiplier = 1; comboEl.textContent = `x${multiplier}`;
    }
  }
  if (inBonus) {
    bonusTimer -= dt;
    if (bonusTimer <= 0) {
      inBonus = false;
      spawnInterval = Math.min(1200, 900 + wave * 10); // relax a bit after bonus
      showToast("Bonus Over");
    }
  }

  drawBackground();

  // Spawn logic
  if (ts - lastSpawn > spawnInterval) {
    spawnEnemy();
    lastSpawn = ts;
    if (!choicesEl.children.length && enemies.length) buildChoices(enemies[0].word);
  }

  // Update enemies
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    const slow = freezeTimer > 0 ? 0.35 : 1;
    e.x -= e.speed * slow * dt;

    // Sneaky fade in/out based on distance
    if (e.type === "sneaky") {
      e.alpha = clamp(0.4 + (e.x / canvas.width) * 0.6, 0.4, 1);
    }

    drawEnemy(e, dt);

    // Reached base
    if (e.x - e.w/2 <= 68) {
      enemies.splice(i, 1);
      lives -= 1;
      livesEl.textContent = lives;
      screenShake();

      // If current target got through, reset target/choices
      if (e.word === currentTargetWord) {
        currentTargetWord = null;
        if (enemies.length > 0) {
          let frontmost = enemies.reduce((p, c) => (p.x < c.x ? p : c));
          currentTargetWord = frontmost.word;
          buildChoices(currentTargetWord);
        } else {
          choicesEl.innerHTML = "";
        }
      }
      if (lives <= 0) { gameOver(); return; }
    }
  }

  // Particles
  updateParticles(dt);
  drawParticles();

  requestAnimationFrame(loop);
}

// -------------------------- Wave Progress --------------------------
function updateWaveProgress() {
  const pct = clamp((waveKills / waveGoal) * 100, 0, 100);
  waveProgressEl.style.width = pct + "%";
}

// -------------------------- Start / Pause / Over --------------------------
function startGame() {
  running = true; paused = false;
  score = 0; lives = 3; wave = 1;
  enemies = []; particles = [];
  currentTargetWord = null; choicesLocked = false;
  lastSpawn = 0;
  baseSpeed = learnMode ? 40 : 52;
  spawnInterval = learnMode ? 1400 : 1100;
  waveGoal = 10; waveKills = 0;
  combo = 0; multiplier = 1; multiplierTimer = 0;
  inBonus = false; bonusTimer = 0;
  freezeTimer = 0; doubleTimer = 0;
  powerups = { freeze: 1, bomb: 1, double: 1 };
  updatePowerupUI();

  scoreEl.textContent = score;
  livesEl.textContent = lives;
  waveEl.textContent = wave;
  comboEl.textContent = "x1";
  waveProgressEl.style.width = "0%";

  lastTime = 0;
  resizeCanvas();
  startOverlay.style.display = "none";
  bonusOverlay.style.display = "none";
  gameOverOverlay.style.display = "none";
  choicesEl.innerHTML = "";

  requestAnimationFrame(loop);
}

function gameOver() {
  running = false; paused = false;
  finalScoreEl.textContent = score;
  // High score
  if (score > highScore) {
    highScore = score;
    localStorage.setItem("hsk_td_highscore", String(highScore));
    highScoreEl.textContent = highScore;
  }
  finalHighScoreEl.textContent = highScore;
  gameOverOverlay.style.display = "flex";
}

function togglePause() {
  if (!running) return;
  paused = !paused;
  pauseBtn.textContent = paused ? "Resume" : "Pause";
  pauseBtn.setAttribute("aria-pressed", paused ? "true" : "false");
  if (!paused) {
    lastTime = 0;
    requestAnimationFrame(loop);
  }
}

// -------------------------- Modes & Level --------------------------
function setMode(m) {
  mode = m;
  modePinyinBtn.classList.toggle("active", m === "pinyin");
  modeEnglishBtn.classList.toggle("active", m === "english");
  if (currentTargetWord) buildChoices(currentTargetWord);
}
function setLearnMode(learn) {
  learnMode = learn;
  modePracticeBtn.classList.toggle("active", learn);
  modeArcadeBtn.classList.toggle("active", !learn);
  showToast(learn ? "Learning Mode" : "Arcade Mode");
}
function setLevel(l) {
  level = l;
  if (currentTargetWord) buildChoices(currentTargetWord);
}

// -------------------------- Responsive Canvas --------------------------
function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // Recompute lanes: 3 lanes centered
  const mid = canvas.height / (2 * dpr);
  lanes = [mid - 50, mid, mid + 50];
}

// -------------------------- Stats storage --------------------------
function loadStats() {
  try {
    return JSON.parse(localStorage.getItem("hsk_td_stats") || "{}");
  } catch(e) {
    return {};
  }
}
function saveStats() {
  try {
    localStorage.setItem("hsk_td_stats", JSON.stringify(stats));
  } catch(e) {}
}

// -------------------------- Wiring UI --------------------------
pauseBtn.addEventListener("click", togglePause);
modePinyinBtn.addEventListener("click", () => setMode("pinyin"));
modeEnglishBtn.addEventListener("click", () => setMode("english"));

modePracticeBtn.addEventListener("click", () => setLearnMode(true));
modeArcadeBtn.addEventListener("click", () => setLearnMode(false));

levelSelect.addEventListener("change", (e) => setLevel(Number(e.target.value)));

startModePinyin.addEventListener("click", () => {
  startModePinyin.classList.add("active");
  startModeEnglish.classList.remove("active");
  setMode("pinyin");
});
startModeEnglish.addEventListener("click", () => {
  startModeEnglish.classList.add("active");
  startModePinyin.classList.remove("active");
  setMode("english");
});
startLevel.addEventListener("change", (e) => {
  levelSelect.value = e.target.value;
  setLevel(Number(e.target.value));
});

startBtn.addEventListener("click", () => {
  setLevel(Number(startLevel.value));
  startOverlay.style.display = "none";
  startGame();
});
bonusStartBtn.addEventListener("click", () => {
  startBonus();
  lastTime = 0;
  requestAnimationFrame(loop);
});
restartBtn.addEventListener("click", () => {
  gameOverOverlay.style.display = "none";
  startGame();
});

// Power-ups
puFreezeBtn.addEventListener("click", useFreeze);
puBombBtn.addEventListener("click", useBomb);
puDoubleBtn.addEventListener("click", useDouble);

// Init
resizeCanvas();
announce("Game loaded. Choose a mode and press Start.");
</script>
</body>
</html>
